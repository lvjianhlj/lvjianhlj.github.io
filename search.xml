<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>生成窗口最大值数组</title>
      <link href="/2018/07/13/getMaxWindow/"/>
      <url>/2018/07/13/getMaxWindow/</url>
      <content type="html"><![CDATA[<p>【题目】</p><p>　　有一个整型数组arr和一个大小为w的窗口从数组的最左边滑到最右边，窗口每次向右滑动一个位置。<br>　　<br>　　例如，数组为[4,3,5,4,3,3,6,7]，窗口大小为3时：依次出现的窗口为[4,3,5], [3,5,4], [5,4,3], [4,3,3], [3,3,6], [3,6,7]。</p><p>　　如果数组长度是n，窗口大小是w，则一共产生n-w+1个窗口。<br>　　<br>　　请实现一个函数。</p><p>　　1、输入：整型数组arr，窗口大小w<br>　　2、输出：一个长度大小为n-w+1的数组res，res[i]表示每一种窗口下的最大值。例如上面的例子，应该返回[5,5,5,4,6,7]。</p><p>【基本思路】</p><p>　　使用双端队列，遍历一遍数组，假设遍历到的位置是 i，如果队列为空或者队尾所对应的元素大于arr[i]，将位置 i 压入队列；否则将队尾元素弹出，再将 i 压入队列。此时，判断队头元素是否等于i - w，如果是的话说明此时队头已经不在当前窗口的范围内，删去。这样，这个队列就成了一个维护窗口为w的子数组的最大值更新的结构，队头元素就是每个窗口的最大值。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#python3.5</span><br><span class="line">def getMaxWindow(arr, w):</span><br><span class="line">    if arr == None or w &lt; 1 or len(arr) &lt; w:</span><br><span class="line">        return</span><br><span class="line">    deque = []</span><br><span class="line">    res = []</span><br><span class="line">    for i in range(len(arr)):</span><br><span class="line">        while deque and arr[deque[-1]] &lt;= arr[i]:</span><br><span class="line">            deque.pop()</span><br><span class="line">        deque.append(i)</span><br><span class="line">        if deque[0] &lt;= i - w:</span><br><span class="line">            deque.pop(0)</span><br><span class="line">        if i-w+1 &gt;= 0:</span><br><span class="line">            res.append(arr[deque[0]])</span><br><span class="line">    return res</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pyhton </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈和队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用一个栈实现另一个栈的排序</title>
      <link href="/2018/07/12/sortByStack/"/>
      <url>/2018/07/12/sortByStack/</url>
      <content type="html"><![CDATA[<p>【题目】</p><p>　　一个栈中元素的类型是整型，现在想将该栈从顶到底按从大到小的顺序排序，只许申请一个栈。除此之外，可以申请新的变量，但不能申请额外的数据结构。如何完成排序？</p><p>【基本思路】</p><p>　　不断将栈顶元素cur弹出，如果新栈为空、或者新栈栈顶元素大于cur，直接将cur压入新栈中；否则，将新栈中的元素逐一弹出压回原来的栈中，直到新栈的栈顶元素大于cur，再将cur压入新栈中.继续弹出原来栈的栈顶元素，重复上述操作即可。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#python3.5</span><br><span class="line">def sortByStack(stack):</span><br><span class="line">    if len(stack) &lt; 2:</span><br><span class="line">        return stack</span><br><span class="line">    stack1 = []</span><br><span class="line">    while stack:</span><br><span class="line">        cur = stack.pop()</span><br><span class="line">        while len(stack1) != 0 and stack1[-1] &lt; cur:</span><br><span class="line">            stack.push(stack1.pop())</span><br><span class="line">        stack1.push(cur)</span><br><span class="line">    while stack1:</span><br><span class="line">        stack.append(stack1.pop())</span><br><span class="line">    return stack</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pyhton </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈和队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>猫狗队列</title>
      <link href="/2018/07/11/CatDogQueue/"/>
      <url>/2018/07/11/CatDogQueue/</url>
      <content type="html"><![CDATA[<p>【题目】</p><p>　　实现一种狗猫队列的结构， 要求如下： 用户可以调用add方法将cat类或dog类的实例放入队列中； 用户可以调用pollAll方法， 将队列中所有的实例按照进队列的先后顺序依次弹出； 用户可以调用pollDog方法， 将队列中dog类的实例按照进队列的先后顺序依次弹出； 用户可以调用pollCat方法， 将队列中cat类的实例按照进队列的先后顺序依次弹出； 用户可以调用isEmpty方法， 检查队列中是否还有dog或cat的实例； 用户可以调用isDogEmpty方法， 检查队列中是否有dog类的实例； 用户可以调用isCatEmpty方法， 检查队列中是否有cat类的实例。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#python3.5</span><br><span class="line">class Pet(object):</span><br><span class="line">    def __init__(self, type):</span><br><span class="line">        self.type = type</span><br><span class="line"></span><br><span class="line">    def get_pet(self):</span><br><span class="line">        return self.type</span><br><span class="line"></span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return self.type</span><br><span class="line"></span><br><span class="line">class Dog(Pet):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        Pet.__init__(self, &apos;dog&apos;)</span><br><span class="line"></span><br><span class="line">class Cat(Pet):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        Pet.__init__(self, &apos;cat&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class PetCount(object):</span><br><span class="line">    def __init__(self, pet, count):</span><br><span class="line">        self.pet = pet</span><br><span class="line">        self.count = count</span><br><span class="line"></span><br><span class="line">    def get_count(self):</span><br><span class="line">        return self.count</span><br><span class="line"></span><br><span class="line">    def get_pet(self):</span><br><span class="line">        return self.pet</span><br><span class="line"></span><br><span class="line">    def get_type(self):</span><br><span class="line">        return self.pet.type</span><br><span class="line"></span><br><span class="line">class CatDogQueue(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.dog_queue = []</span><br><span class="line">        self.cat_queue = []</span><br><span class="line">        self.count = 0</span><br><span class="line"></span><br><span class="line">    def add(self, pet):</span><br><span class="line"></span><br><span class="line">        if pet.type == &apos;dog&apos;:</span><br><span class="line">            self.count += 1</span><br><span class="line">            pet_count = PetCount(pet, self.count)</span><br><span class="line">            self.dog_queue.append(pet_count)</span><br><span class="line">        elif pet.type == &apos;cat&apos;:</span><br><span class="line">            self.count += 1</span><br><span class="line">            pet_count = PetCount(pet, self.count)</span><br><span class="line">            self.cat_queue.append(pet_count)</span><br><span class="line">        else:</span><br><span class="line">            raise RuntimeError(&apos;no pet type&apos;)</span><br><span class="line"></span><br><span class="line">    def pull_all(self):</span><br><span class="line">        if not self.is_empty():</span><br><span class="line">            if self.is_cat_queue_empty():</span><br><span class="line">                count_dog = self.dog_queue.pop(0)</span><br><span class="line">                return count_dog.get_pet()</span><br><span class="line">            elif self.is_dog_queue_empty():</span><br><span class="line">                count_cat = self.cat_queue.pop(0)</span><br><span class="line">                return count_cat.get_pet()</span><br><span class="line">            else:</span><br><span class="line">                count_dog = self.dog_queue[0]</span><br><span class="line">                count_cat = self.cat_queue[0]</span><br><span class="line">                if count_cat.get_count() &lt; count_dog.get_count():</span><br><span class="line">                    self.cat_queue.pop(0)</span><br><span class="line">                    return count_cat.get_pet()</span><br><span class="line">                else:</span><br><span class="line">                    self.dog_queue.pop(0)</span><br><span class="line">                    return count_dog.get_pet()</span><br><span class="line">        else:</span><br><span class="line">            raise RuntimeError(&apos;queue is empty&apos;)</span><br><span class="line"></span><br><span class="line">    def pull_dog(self):</span><br><span class="line">        if not self.is_dog_queue_empty():</span><br><span class="line">            return self.dog_queue.pop(0).get_pet()</span><br><span class="line">        else:</span><br><span class="line">            raise RuntimeError(&apos;dog queue is empty&apos;)</span><br><span class="line"></span><br><span class="line">    def pull_cat(self):</span><br><span class="line">        if not self.is_cat_queue_empty():</span><br><span class="line">            return self.cat_queue.pop(0).get_pet()</span><br><span class="line">        else:</span><br><span class="line">            raise RuntimeError(&apos;dog queue is empty&apos;)</span><br><span class="line"></span><br><span class="line">    def is_empty(self):</span><br><span class="line">        return self.is_cat_queue_empty() and self.is_dog_queue_empty()</span><br><span class="line"></span><br><span class="line">    def is_dog_queue_empty(self):</span><br><span class="line">        return not self.dog_queue</span><br><span class="line"></span><br><span class="line">    def is_cat_queue_empty(self):</span><br><span class="line">        return not self.cat_queue</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pyhton </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈和队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计一个有getMin功能的栈</title>
      <link href="/2018/07/10/getMin/"/>
      <url>/2018/07/10/getMin/</url>
      <content type="html"><![CDATA[<p>【题目】</p><p>　　实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。</p><p>【要求】</p><p>　　1、 pop、push、getMin操作的时间复杂度都是O(1)<br>　　2.、设计的栈类型可以使用现成的栈结构<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#python3.5</span><br><span class="line">class NewStack1:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.stackData = []</span><br><span class="line">        self.stackMin = []</span><br><span class="line"></span><br><span class="line">    def push(self, newNum):</span><br><span class="line">        self.stackData.append(newNum)</span><br><span class="line">        if len(self.stackMin) == 0 or newNum &lt;= self.getMin():</span><br><span class="line">            self.stackMin.append(newNum)</span><br><span class="line"></span><br><span class="line">    def pop(self):</span><br><span class="line">        if len(self.stackData) == 0:</span><br><span class="line">            raise Exception(&quot;stack is empty!&quot;)</span><br><span class="line">        value = self.stackData.pop()</span><br><span class="line">        if self.getMin() == value:</span><br><span class="line">            self.stackMin.pop()</span><br><span class="line">        return value</span><br><span class="line"></span><br><span class="line">    def getMin(self):</span><br><span class="line">        if len(self.stackMin) == 0:</span><br><span class="line">            raise Exception(&quot;stack is empty!&quot;)</span><br><span class="line">        return self.stackMin[-1]</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pyhton </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈和队列 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
